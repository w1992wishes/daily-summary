package me.w1992wishes.to.offer.integer;

/**
 * 给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。
 */
public class CountBits {

    /**
     * 要在O(n)的时间复杂度下一次性扫描做到，那就必然得找出这组数的联系，从二进制数字的进位中可以发现：
     * <p>
     * 如果此二进制数字末位为1，那么它的比特位计数就比和它小1的二进制数字刚好多了一个比特位，如：整数3--->二进制011，整数2（3-1）--->二进制010，整数3比特位计数 = 整数2比特位计数 + 1（末位0变1式进位），
     * <p>
     * 如果此二进制数字末位不为1，那么它的比特位计数就等于比和它小1的二进制数字的比特位计数，如：整数2--->二进制010，整数1（2-1）--->二进制001，整数2比特位计数 = 整数1比特位计数 （末位1向前进位），
     * <p>
     * 此时，若数字 i 与（i-1）作&运算，若i末位是1，相当于抹去的是i 末位0变1的1，若i末位不是1，则抹去的是i 中向前进位的1，即
     * i的比特位计数 = i&（i-1）的比特位计数 + 1。
     * 因为i&（i-1）小于i,所以我们可以使用前面的数计算出后面的数，基数也就是0的比特位基数是0.
     */
    public int[] countBits(int n) {
        int res[] = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            if (i == 0) {
                res[i] = 0;
            } else {
                res[i] = res[i & (i - 1)] + 1;
            }
        }
        return res;
    }

}
